<html>
<head>
<title>Gameutils.js Particle Effect Editor</title>
<style>
textarea {
    position: absolute;
    left: 650px;
    top: 55px;
    white-space: pre;
    word-wrap: normal;
    overflow-x: scroll;
}
</style>
<script src="../src/sprite.js"></script><!-- required for Particle.prerenderedCircleAppearance -->
<script src="../src/particle.js"></script>
<script src="../src/lib/dat.gui.js"></script>
<script src="../src/gameparameters.js"></script>
<script>
'use strict';

var ctx;
var editor;

var loadFileInput = function(fileInput, urlCallback) {
    var file = fileInput.files[0];
    var reader = new FileReader();
    reader.onload = function(evt) {
        urlCallback(evt.target.result);
    };
    reader.readAsDataURL(file);
};

var loadSpriteFromFileInput = function() {
    var fileInput = document.getElementById('imageFile');
    loadFileInput(fileInput, function(fileSrc) {
        editor.parameters.set('spriteURL', fileSrc);
    });
};

var Editor = function() {
    this.time = 0;
    this.particles = new ParticleEngine({gravityY: 100});
    this._appearanceOptions = {};
    this._loadedAppearanceOptions = {};
    this.emitter = new ParticleEmitter({
        appearance: Particle.prerenderedCircleAppearance('#fff', 8, this._appearanceOptions)
    });
    this.effect = new ParticleEffect({
        emitter: this.emitter,
        engine: this.particles
    });
    this._color = '#fff';
    this._colorSprite = false;
    this.sprite = null;
    this.loadedSpriteURL = '';
    
    this.codeArea = document.createElement('textarea');
    this.codeArea.cols = 80;
    this.codeArea.rows = 40;
    this.codeArea.readOnly = true;
    this._appearanceCodePrefix = '';
    this._appearanceCode = '';
    
    this.parameters = new GameParameters(particleParameters);
    this.parameters.initGUI(
        {
          "preset": "Trail",
          "remembered": {
            "Default": {
              "0": {
                "minVelocity": 10,
                "maxVelocity": 80,
                "positionSpread": 10,
                "direction": 0,
                "directionSpread": 360,
                "minLifetime": 1,
                "maxLifetime": 3,
                "size": 5,
                "opacity": 1,
                "inertia": 1,
                "weight": 1,
                "directionMode": "RELATIVE",
                "particleInterval": 0.016666666666666666
              }
            },
            "Trail": {
              "0": {
                "minVelocity": 10,
                "maxVelocity": 54.19137793500506,
                "positionSpread": 10,
                "direction": 180,
                "directionSpread": 20,
                "minLifetime": 1,
                "maxLifetime": 3,
                "size": 29.970710644053703,
                "opacity": 1,
                "inertia": 1,
                "weight": -0.6748517323899696,
                "directionMode": "RELATIVE",
                "particleInterval": 0.011437343206279846
              }
            }
          },
          "closed": false,
          "folders": {}
        }
    );
};

Editor.prototype.generateCode = function() {
    var code = [];
    if (this._appearanceCodePrefix != '') {
        code.push(this._appearanceCodePrefix);
    }
    code.push('var emitter = new ParticleEmitter({');
    var specialEmitterKeys = {'x': false, 'y': false, 'appearance': false, 'rotationMode': false, 'sizeFunc': true, 'opacityFunc': true};
    for (var key in this.emitter.options) {
        if (this.emitter.options.hasOwnProperty(key) && !specialEmitterKeys.hasOwnProperty(key)) {
            if (typeof this.emitter.options[key] === 'string') {
                code.push('    ' + key + ': "' + this.emitter.options[key] + '",');
            } else {
                code.push('    ' + key + ': ' + this.emitter.options[key] + ',');
            }
        }
    }
    code.push('    rotationMode: Particle.RotationMode.' + this.parameters.get('rotationMode') + ',');
    var functions = ['Particle.fastAppearSlowDisappear', 'Particle.fadeOutLinear'];
    for (var key in specialEmitterKeys) {
        if (specialEmitterKeys.hasOwnProperty(key) && specialEmitterKeys[key]) {
            for (var i = 0; i < functions.length; ++i) {
                if (eval(functions[i]) === this.emitter.options[key]) {
                    code.push('    ' + key + ': ' + functions[i] + ',');
                }
            }
        }
    }
    code.push('    appearance: ' + this._appearanceCode + ',');
    // Remove extra comma
    code[code.length - 1] = code[code.length - 1].substring(0, code[code.length - 1].length - 1);
    code.push('});');
    code.push('var effect = new ParticleEffect({');
    code.push('    emitter: emitter,');
    code.push('    directionMode: ParticleEffect.DirectionMode.' + this.parameters.get('directionMode') + ',');
    code.push('    particleInterval: ' + this.parameters.get('particleInterval') + ',');
    // Remove extra comma
    code[code.length - 1] = code[code.length - 1].substring(0, code[code.length - 1].length - 1);
    code.push('});');
    return code.join('\n');
};

Editor.prototype.update = function() {
    var deltaTime = 1 / 60; // Assume 60 fps... bad example :P
    this.time += deltaTime;
    
    // Refresh parameters:
    
    for (var key in particleParameters) {
        if (this.emitter.options.hasOwnProperty(key)) {
            this.emitter.options[key] = this.parameters.get(key);
        }
    }
    this.emitter.options.rotationMode = Particle.RotationMode[this.parameters.get('rotationMode')];
    this.effect.directionMode = ParticleEffect.DirectionMode[this.parameters.get('directionMode')];
    this.effect.particleInterval = this.parameters.get('particleInterval');
    
    this.codeArea.textContent = this.generateCode();
    
    this.updateAppearance();

    // Update:

    this.particles.update(deltaTime);
    var width = ctx.canvas.width;
    var height = ctx.canvas.height;
    var posX = width * 0.5 + Math.sin(this.time * 2.9) * width * 0.4;
    var posY = height * 0.5 + Math.cos(this.time * 1.9) * height * 0.4;
    this.effect.setCoords(posX, posY);
    this.effect.update(deltaTime);

    // Draw:

    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    this.particles.render(ctx);
};

Editor.prototype.updateAppearance = function() {
    this._appearanceOptions.size = this.parameters.get('size');
    if (this.parameters.get('spriteURL') !== '' && this.sprite && this.sprite.loaded) {
        this._appearanceOptions.size /= this.sprite.width;
    }
    this._appearanceOptions.opacity = this.parameters.get('opacity');
    var appearanceSame = true;
    for (var key in this._appearanceOptions) {
        if (this._appearanceOptions.hasOwnProperty(key)) {
            if (this._loadedAppearanceOptions[key] !== this._appearanceOptions[key]) {
                appearanceSame = false;
            }
        }
    }
    if (appearanceSame &&
        this._color === this.parameters.get('color') &&
        this._colorSprite === this.parameters.get('colorSprite') &&
        this._loadedSpriteURL === this.parameters.get('spriteURL'))
    {
        return;
    }
    var updatedAppearance;
    var appearanceOptionsString = '{';
    appearanceOptionsString += 'size: ' + this._appearanceOptions.size + ', ';
    appearanceOptionsString += 'opacity: ' + this._appearanceOptions.opacity;
    appearanceOptionsString += '}';
    if (this.parameters.get('spriteURL') !== '') {
        if (this.sprite === null || this.sprite.filename !== this.parameters.get('spriteURL')) {
            this.sprite = new Sprite(this.parameters.get('spriteURL'));
        }
        if (this.sprite.loaded) {
            this.loadedSprite = this.sprite;
            if (this.parameters.get('colorSprite')) {
                var coloredSprite = new Sprite(this.sprite.filename, Sprite.turnSolidColored(this._color));
                updatedAppearance = Particle.spriteAppearance(coloredSprite, this._appearanceOptions);
                this._appearanceCodePrefix = 'var sprite = new Sprite("' + this.sprite.filename + '", Sprite.turnSolidColored("' + this._color + '"));';
                this._appearanceCode = 'Particle.spriteAppearance(sprite, ' + 1 / this.sprite.width + ', ' + appearanceOptionsString + ')';
            } else {
                updatedAppearance = Particle.spriteAppearance(this.sprite, this._appearanceOptions);
                this._appearanceCodePrefix = 'var sprite = new Sprite("' + this.sprite.filename + '");';
                this._appearanceCode = 'Particle.spriteAppearance(sprite, ' + 1 / this.sprite.width + ', ' + appearanceOptionsString + ')';
            }
        }
    } else {
        updatedAppearance = Particle.prerenderedCircleAppearance(this._color, 8, this._appearanceOptions);
        this._appearanceCodePrefix = '';
        this._appearanceCode = 'Particle.prerenderedCircleAppearance("' + this._color + '", 8, ' + appearanceOptionsString + ')';
    }
    
    if (updatedAppearance !== undefined) {
        this.emitter.options.appearance = updatedAppearance;
        this._colorSprite = this.parameters.get('colorSprite');
        this._color = this.parameters.get('color');
        this._loadedSpriteURL = this.parameters.get('spriteURL');
        for (var key in this._appearanceOptions) {
            if (this._appearanceOptions.hasOwnProperty(key)) {
                this._loadedAppearanceOptions[key] = this._appearanceOptions[key];
            }
        }
    }
};

var frame = function() {
    editor.update();
    requestAnimationFrame(frame);
};

var particleParameters = {
    'minVelocity': {initial: 10, min: 0, max: 1000},
    'maxVelocity': {initial: 80, min: 0, max: 1000},
    'positionSpread': {initial: 10, min: 0, max: 100},
    'direction': {initial: 0, min: 0, max: 360, step: 10},
    'directionSpread': {initial: 360, min: 0, max: 360, step: 10},
    'minLifetime': {initial: 1, min: 0.1, max: 20},
    'maxLifetime': {initial: 3, min: 0.1, max: 20},
    'size': {initial: 5, min: 1, max: 100},
    'opacity': {initial: 1, min: 0, max: 1},
    'inertia': {initial: 1, min: 0.1, max: 10},
    'weight': {initial: 1, min: -1, max: 1},
    'rotation': {initial: 360, min: 0, max: 360, step: 10},
    'rotationMode': {options: ['STATIC', 'CURRENT_DIRECTION', 'INITIAL_DIRECTION']},
    'directionMode': {options: ['RELATIVE', 'ABSOLUTE']},
    'particleInterval': {initial: 1/60, min: 1/240, max: 0.1},
    'color': {initial: '#fff', color: true},
    'colorSprite': {initial: false},
    'spriteURL': {initial: ''}
};

var start = function() {
    editor = new Editor();
    var canvas = document.createElement('canvas');
    canvas.width = 600;
    canvas.height = 600;
    ctx = canvas.getContext('2d');
    document.body.appendChild(canvas);
    var div = document.createElement('div');
    div.innerHTML = '<input type="file" id="imageFile"></input><input type="button" onclick="loadSpriteFromFileInput()" value="Load sprite"></input>'
    document.body.appendChild(div);
    document.body.appendChild(editor.codeArea);
    frame();
};
</script>
</head>
<body onload="start()">
<h2>Gameutils.js Particle Effect Editor</h2>
</body>
</html>
